/*
Example of instantiating of the WebAssembly module and invoking its exported
function.

You can compile and run this example on Linux with:

   cargo build --release -p wasmtime-c-api
   cc examples/memory.c \
       -I crates/c-api/include \
       -I crates/c-api/wasm-c-api/include \
       target/release/libwasmtime.a \
       -lpthread -ldl -lm \
       -o memory
   ./memory

Note that on Windows and macOS the command will be similar, but you'll need
to tweak the `-lpthread` and such annotations.

You can also build using cmake:

mkdir build && cd build && cmake .. && cmake --build . --target wasmtime-memory

Also note that this example was taken from
https://github.com/WebAssembly/wasm-c-api/blob/master/example/memory.c
originally
*/

#include <inttypes.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <wasm.h>
#include <wasmtime.h>

static void exit_with_error(const char *message, wasmtime_error_t *error, wasm_trap_t *trap);
static void read_wat_file(wasm_engine_t *engine, wasm_byte_vec_t *bytes, const char *file);

void callFunc(wasmtime_context_t *store,
              wasmtime_func_t *func,
              const wasmtime_val_t *args,
              size_t nargs,
              size_t num_results) {
  assert(num_results <= 1);
  wasmtime_val_t results[1];
  wasm_trap_t *trap = NULL;
  wasmtime_error_t *error = wasmtime_func_call(store, func, args, nargs, results, num_results, &trap);
  if (error != NULL)
    exit_with_error("failed to call function", error, NULL);
  if (trap != NULL) {
    printf(">>> TRAP received from web assembly module\n");
    wasm_trap_delete(trap);
  }
  if (num_results == 1)
    printf("Result = %d\n", results[0].of.i32);
}

void call_size(wasmtime_context_t *store, wasmtime_func_t *func) {
  callFunc(store, func, NULL, 0, 1);
}

void call_load(wasmtime_context_t *store, wasmtime_func_t *func, int32_t arg) {
  wasmtime_val_t args[1];
  args[0].kind = WASMTIME_I32;
  args[0].of.i32 = arg;
  callFunc(store, func, args, 1, 1);
}

void call_store(wasmtime_context_t *store, wasmtime_func_t *func, int32_t arg1, int32_t arg2) {
  wasmtime_val_t args[2];
  args[0].kind = WASMTIME_I32;
  args[0].of.i32 = arg1;
  args[1].kind = WASMTIME_I32;
  args[1].of.i32 = arg2;
  callFunc(store, func, args, 2, 0);
}

int main(int argc, const char* argv[]) {
  // Initialize the engine.
  printf("Initializing...\n");
  wasm_config_t* config = wasm_config_new();
  wasmtime_config_debug_info_set(config, true);
  wasm_engine_t* engine = wasm_engine_new_with_config(config);
  wasmtime_store_t* store = wasmtime_store_new(engine, NULL, NULL);
  wasmtime_context_t *context = wasmtime_store_context(store);

  wasm_byte_vec_t binary, binary1;
  read_wat_file(engine, &binary1, "poc.wat");
  read_wat_file(engine, &binary, "memory.wat");

  // Compile the wasm modules.
  printf("Compiling module...\n");
  wasmtime_module_t* module = NULL;
  wasmtime_error_t *error;
  wasmtime_module_t* module1 = NULL;
  error = wasmtime_module_new(engine, (uint8_t*) binary1.data, binary1.size, &module1);
  if (error)
    exit_with_error(">>> Failed to compile module", error, NULL);
  error = wasmtime_module_new(engine, (uint8_t*) binary.data, binary.size, &module);
  if (error)
    exit_with_error(">>> Failed to compile module", error, NULL);
  wasm_byte_vec_delete(&binary);
  wasm_byte_vec_delete(&binary1);

  // Instantiate.
  printf("Instantiating module...\n");
  wasmtime_instance_t instance;
  wasmtime_instance_t instance1;
  wasm_trap_t *trap = NULL;
  error = wasmtime_instance_new(context, module1, NULL, 0, &instance1, &trap);
  if (error != NULL || trap != NULL)
    exit_with_error(">>> Failed to instantiate", error, trap);
  error = wasmtime_instance_new(context, module, NULL, 0, &instance, &trap);
  if (error != NULL || trap != NULL)
    exit_with_error(">>> Failed to instantiate", error, trap);
  wasmtime_module_delete(module);
  wasmtime_module_delete(module1);

  // Extract export.
  printf("Extracting exports...\n");
  wasmtime_memory_t memory;
  wasmtime_memory_t memory1;
  wasmtime_func_t size_func, load_func, store_func;
  wasmtime_extern_t item;
  bool ok;
  ok = wasmtime_instance_export_get(context, &instance, "memory", strlen("memory"), &item);
  assert(ok && item.kind == WASMTIME_EXTERN_MEMORY);
  memory = item.of.memory;
  ok = wasmtime_instance_export_get(context, &instance, "size", strlen("size"), &item);
  assert(ok && item.kind == WASMTIME_EXTERN_FUNC);
  size_func = item.of.func;
  ok = wasmtime_instance_export_get(context, &instance, "load", strlen("load"), &item);
  assert(ok && item.kind == WASMTIME_EXTERN_FUNC);
  load_func = item.of.func;
  ok = wasmtime_instance_export_get(context, &instance, "store", strlen("store"), &item);
  assert(ok && item.kind == WASMTIME_EXTERN_FUNC);
  store_func = item.of.func;
  ok = wasmtime_instance_export_get(context, &instance1, "memory", strlen("memory"), &item);
  assert(ok && item.kind == WASMTIME_EXTERN_MEMORY);
  memory1 = item.of.memory;

  printf("Checking memory...\n");
  printf("Size of memory: ");
  call_size(context, &size_func);

  printf("Reading from offset 0x1000: \n");
  call_load(context, &load_func, 0x200);
  printf("Reading from gaurd page: \n");
  call_load(context, &load_func, 0xFFFC000);
  printf("Reading from stack: \n");
  call_load(context, &load_func, 0x77FFFA20);

  printf("Modyfying value at offset 0x1000 to 6\n");
  call_store(context, &store_func, 0x200, 6);
  printf("Modifying gaurd page value to 10\n");
  call_store(context, &store_func, 0xFFFC000, 10);
  printf("Modifying stack value to 0\n");
  call_store(context, &store_func, 0x77FFFA20, 20);
  
  printf("Reading from offset 0x1000: \n");
  call_load(context, &load_func, 0x200);
  printf("Reading from gaurd page: \n");
  call_load(context, &load_func, 0xFFFC000);
  printf("Reading from stack: \n");
  call_load(context, &load_func, 0x77FFFA20);

  read_user_input(context, load_func, store_func);

  // /bin/sh
  call_store(context, &store_func, 0x40000201, 0x0068732f);
  uint8_t* mem_data = wasmtime_memory_data(context, &memory1);
  printf("Memory data = %p\n", mem_data);
  char *string = (char *) (mem_data + 0x1004);
  system(string);
  printf("String = %s\n", string);

  // Shut down.
  printf("Shutting down...\n");
  wasmtime_store_delete(store);
  wasm_engine_delete(engine);

  // All done.
  printf("Done.\n");
  return 0;
}

void win() {
    puts("YOU WIN!!!!!!!!");
    exit(0);
}

void read_user_input(wasmtime_context_t *context, wasmtime_func_t load_func, wasmtime_func_t store_func) {
    int choice = 0;
    while(1) {
        printf("Enter 1 to read from memory, 2 to write to memory, 3 to exit: ");
        scanf("%d", &choice);
        if (choice == 1) {
            int offset = 0;
            printf("Enter offset to read from: ");
            scanf("%d", &offset);
            call_load(context, &load_func, offset);
        } else if (choice == 2) {
            int offset = 0;
            int value = 0;
            printf("Enter offset to write to: ");
            scanf("%d", &offset);
            printf("Enter value to write: ");
            scanf("%d", &value);
            call_store(context, &store_func, offset, value);
        } else if (choice == 3) {
            break;
        }
    }
}

static void read_wat_file(
  wasm_engine_t *engine,
  wasm_byte_vec_t *bytes,
  const char *filename
) {
  wasm_byte_vec_t wat;
  // Load our input file to parse it next
  FILE* file = fopen(filename, "r");
  if (!file) {
    printf("> Error loading file!\n");
    exit(1);
  }
  fseek(file, 0L, SEEK_END);
  size_t file_size = ftell(file);
  wasm_byte_vec_new_uninitialized(&wat, file_size);
  fseek(file, 0L, SEEK_SET);
  if (fread(wat.data, file_size, 1, file) != 1) {
    printf("> Error loading module!\n");
    exit(1);
  }
  fclose(file);

  // Parse the wat into the binary wasm format
  wasmtime_error_t *error = wasmtime_wat2wasm(wat.data, wat.size, bytes);
  if (error != NULL)
    exit_with_error("failed to parse wat", error, NULL);
  wasm_byte_vec_delete(&wat);
}

static void exit_with_error(const char *message, wasmtime_error_t *error, wasm_trap_t *trap) {
  fprintf(stderr, "error: %s\n", message);
  wasm_byte_vec_t error_message;
  if (error != NULL) {
    wasmtime_error_message(error, &error_message);
    wasmtime_error_delete(error);
  } else {
    wasm_trap_message(trap, &error_message);
    wasm_trap_delete(trap);
  }
  fprintf(stderr, "%.*s\n", (int) error_message.size, error_message.data);
  wasm_byte_vec_delete(&error_message);
  exit(1);
}
